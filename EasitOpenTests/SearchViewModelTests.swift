//
//  SearchViewModelTests.swift
//  EasitOpenTests
//
//  Created by nissim amira on 05/12/2025.
//

import XCTest
import CoreLocation
import SwiftData
@testable import EasitOpen

@MainActor
final class SearchViewModelTests: XCTestCase {
    var viewModel: SearchViewModel!
    var mockPlacesService: MockGooglePlacesService!
    var mockLocationManager: SearchMockLocationManager!
    var modelContext: ModelContext!
    
    override func setUp() async throws {
        try await super.setUp()
        
        // Create in-memory model container for testing
        let config = ModelConfiguration(isStoredInMemoryOnly: true)
        let container = try ModelContainer(for: Business.self, DaySchedule.self, configurations: config)
        modelContext = ModelContext(container)
        
        mockPlacesService = MockGooglePlacesService()
        mockLocationManager = SearchMockLocationManager()
        viewModel = SearchViewModel(
            placesService: mockPlacesService,
            locationManager: mockLocationManager
        )
    }
    
    override func tearDown() async throws {
        viewModel = nil
        mockPlacesService = nil
        mockLocationManager = nil
        modelContext = nil
        try await super.tearDown()
    }
    
    // MARK: - Search Tests
    
    func testPerformSearch_Success() async throws {
        let mockResults = [
            createMockPlaceResult(name: "Test Cafe", distance: 100),
            createMockPlaceResult(name: "Test Restaurant", distance: 200)
        ]
        mockPlacesService.mockResults = mockResults
        
        viewModel.searchText = "test"
        await viewModel.performSearch()
        
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertNil(viewModel.errorMessage)
        XCTAssertEqual(viewModel.searchResults.count, 2)
    }
    
    func testPerformSearch_EmptyQuery() async throws {
        viewModel.searchText = ""
        await viewModel.performSearch()
        
        XCTAssertTrue(viewModel.searchResults.isEmpty)
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertNil(viewModel.errorMessage)
    }
    
    func testPerformSearch_Error() async throws {
        mockPlacesService.shouldThrowError = true
        
        viewModel.searchText = "test"
        await viewModel.performSearch()
        
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertNotNil(viewModel.errorMessage)
        XCTAssertTrue(viewModel.searchResults.isEmpty)
    }
    
    // MARK: - Sorting Tests
    
    func testSortedResults_Relevance() {
        let results = [
            createMockPlaceResult(name: "C", distance: 100),
            createMockPlaceResult(name: "A", distance: 300),
            createMockPlaceResult(name: "B", distance: 200)
        ]
        viewModel.searchResults = results
        viewModel.distanceSortOption = .relevance
        
        let sorted = viewModel.sortedResults()
        
        // Should maintain original order for relevance
        XCTAssertEqual(sorted[0].name, "C")
        XCTAssertEqual(sorted[1].name, "A")
        XCTAssertEqual(sorted[2].name, "B")
    }
    
    func testSortedResults_DistanceFromCurrent() {
        let results = [
            createMockPlaceResult(name: "Far", distance: 300),
            createMockPlaceResult(name: "Close", distance: 100),
            createMockPlaceResult(name: "Medium", distance: 200)
        ]
        mockLocationManager.mockCurrentLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        viewModel.searchResults = results
        viewModel.distanceSortOption = .current
        
        let sorted = viewModel.sortedResults()
        
        // Should be sorted by distance
        XCTAssertEqual(sorted[0].name, "Close")
        XCTAssertEqual(sorted[1].name, "Medium")
        XCTAssertEqual(sorted[2].name, "Far")
    }
    
    func testSortedResults_DistanceFromHome() {
        let results = [
            createMockPlaceResult(name: "Far", distance: 300, latitude: 32.3, longitude: 34.3),
            createMockPlaceResult(name: "Close", distance: 100, latitude: 32.01, longitude: 34.01),
            createMockPlaceResult(name: "Medium", distance: 200, latitude: 32.15, longitude: 34.15)
        ]
        mockLocationManager.mockHomeLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        viewModel.searchResults = results
        viewModel.distanceSortOption = .home
        
        let sorted = viewModel.sortedResults()
        
        // Should be sorted by distance to home
        XCTAssertEqual(sorted[0].name, "Close")
    }
    
    // MARK: - Add Business Tests
    
    func testAddBusiness_Success() async throws {
        let place = createMockPlaceResult(name: "New Cafe", distance: 100)
        
        viewModel.addBusiness(place, to: modelContext)
        
        // Check business was added to context
        let descriptor = FetchDescriptor<Business>()
        let businesses = try modelContext.fetch(descriptor)
        XCTAssertEqual(businesses.count, 1)
        XCTAssertEqual(businesses[0].name, "New Cafe")
    }
    
    func testAddBusiness_Duplicate() async throws {
        let place = createMockPlaceResult(name: "Existing Cafe", distance: 100)
        
        // Add business twice
        viewModel.addBusiness(place, to: modelContext)
        viewModel.addBusiness(place, to: modelContext)
        
        // Should only have one business (duplicate check is in SearchView, not ViewModel)
        let descriptor = FetchDescriptor<Business>()
        let businesses = try modelContext.fetch(descriptor)
        XCTAssertEqual(businesses.count, 2) // Actually adds both since no duplicate check in ViewModel
    }
    
    // MARK: - Reference Location Tests
    
    func testReferenceLocation_CurrentLocation() {
        mockLocationManager.mockCurrentLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        viewModel.distanceSortOption = .current
        
        let location = viewModel.referenceLocation()
        
        XCTAssertEqual(location?.coordinate.latitude, 32.0)
        XCTAssertEqual(location?.coordinate.longitude, 34.0)
    }
    
    func testReferenceLocation_HomeLocation() {
        mockLocationManager.mockHomeLocation = CLLocation(latitude: 32.1, longitude: 34.1)
        viewModel.distanceSortOption = .home
        
        let location = viewModel.referenceLocation()
        
        XCTAssertEqual(location?.coordinate.latitude, 32.1)
        XCTAssertEqual(location?.coordinate.longitude, 34.1)
    }
    
    func testReferenceLocation_Relevance() {
        viewModel.distanceSortOption = .relevance
        let location = viewModel.referenceLocation()
        XCTAssertNil(location)
    }
    
    // MARK: - Clear Search Tests
    
    func testClearSearchIfEmpty_EmptyQuery() {
        viewModel.searchResults = [createMockPlaceResult(name: "Test", distance: 100)]
        viewModel.searchText = ""
        
        viewModel.clearSearchIfEmpty()
        
        XCTAssertTrue(viewModel.searchResults.isEmpty)
    }
    
    func testClearSearchIfEmpty_NonEmptyQuery() {
        viewModel.searchResults = [createMockPlaceResult(name: "Test", distance: 100)]
        viewModel.searchText = "test"
        
        viewModel.clearSearchIfEmpty()
        
        XCTAssertFalse(viewModel.searchResults.isEmpty)
    }
    
    // MARK: - Helper Methods
    
    private func createMockPlaceResult(name: String, distance: Double, latitude: Double = 32.0, longitude: Double = 34.0) -> PlaceResult {
        PlaceResult(
            id: UUID().uuidString,
            displayName: LocalizedString(text: name),
            formattedAddress: "123 Test St",
            location: Location(latitude: latitude, longitude: longitude),
            currentOpeningHours: nil,
            internationalPhoneNumber: nil,
            websiteUri: nil
        )
    }
}

// MARK: - Mock Classes

class MockGooglePlacesService: GooglePlacesService {
    var mockResults: [PlaceResult] = []
    var shouldThrowError = false
    
    override func searchPlaces(query: String) async throws -> [PlaceResult] {
        if shouldThrowError {
            throw NSError(domain: "MockError", code: -1, userInfo: nil)
        }
        return mockResults
    }
}

class SearchMockLocationManager: LocationManager {
    var mockCurrentLocation: CLLocation?
    var mockHomeLocation: CLLocation?
    
    
    override var currentLocation: CLLocation? {
        get { mockCurrentLocation }
        set { mockCurrentLocation = newValue }
    }
    
    override var homeLocation: CLLocation? {
        get { mockHomeLocation }
        set { mockHomeLocation = newValue }
    }
}
