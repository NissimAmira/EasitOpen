//
//  BusinessRefreshServiceTests.swift
//  EasitOpenTests
//
//  Created by nissim amira on 04/12/2025.
//

import XCTest
@testable import EasitOpen

final class BusinessRefreshServiceTests: XCTestCase {
    
    var refreshService: BusinessRefreshService!
    
    override func setUp() {
        super.setUp()
        refreshService = BusinessRefreshService()
    }
    
    // MARK: - Time Formatting Tests
    
    func testFormatTimeMidnight() {
        // Midnight = 0 minutes
        let formatted = callFormatTime(0)
        XCTAssertEqual(formatted, "12:00 AM")
    }
    
    func testFormatTimeNoon() {
        // Noon = 12 * 60 = 720 minutes
        let formatted = callFormatTime(720)
        XCTAssertEqual(formatted, "12:00 PM")
    }
    
    func testFormatTimeMorning() {
        // 9:30 AM = 9 * 60 + 30 = 570 minutes
        let formatted = callFormatTime(570)
        XCTAssertEqual(formatted, "9:30 AM")
    }
    
    func testFormatTimeAfternoon() {
        // 3:45 PM = 15 * 60 + 45 = 945 minutes
        let formatted = callFormatTime(945)
        XCTAssertEqual(formatted, "3:45 PM")
    }
    
    func testFormatTimeEvening() {
        // 11:59 PM = 23 * 60 + 59 = 1439 minutes
        let formatted = callFormatTime(1439)
        XCTAssertEqual(formatted, "11:59 PM")
    }
    
    func testFormatTime1AM() {
        // 1:00 AM = 1 * 60 = 60 minutes
        let formatted = callFormatTime(60)
        XCTAssertEqual(formatted, "1:00 AM")
    }
    
    func testFormatTime1PM() {
        // 1:00 PM = 13 * 60 = 780 minutes
        let formatted = callFormatTime(780)
        XCTAssertEqual(formatted, "1:00 PM")
    }
    
    // MARK: - Day Name Tests
    
    func testDayNameSunday() {
        let dayName = callDayName(1)
        XCTAssertEqual(dayName, "Sunday")
    }
    
    func testDayNameMonday() {
        let dayName = callDayName(2)
        XCTAssertEqual(dayName, "Monday")
    }
    
    func testDayNameTuesday() {
        let dayName = callDayName(3)
        XCTAssertEqual(dayName, "Tuesday")
    }
    
    func testDayNameWednesday() {
        let dayName = callDayName(4)
        XCTAssertEqual(dayName, "Wednesday")
    }
    
    func testDayNameThursday() {
        let dayName = callDayName(5)
        XCTAssertEqual(dayName, "Thursday")
    }
    
    func testDayNameFriday() {
        let dayName = callDayName(6)
        XCTAssertEqual(dayName, "Friday")
    }
    
    func testDayNameSaturday() {
        let dayName = callDayName(7)
        XCTAssertEqual(dayName, "Saturday")
    }
    
    func testDayNameInvalidLow() {
        let dayName = callDayName(0)
        XCTAssertEqual(dayName, "Unknown")
    }
    
    func testDayNameInvalidHigh() {
        let dayName = callDayName(8)
        XCTAssertEqual(dayName, "Unknown")
    }
    
    // MARK: - RefreshResult Tests
    
    func testRefreshResultSuccess() {
        let business = Business(
            name: "Test",
            address: "Address",
            latitude: 0,
            longitude: 0
        )
        
        let change = BusinessChange(
            type: .hoursChanged(day: "Monday", oldHours: "9-5", newHours: "10-6"),
            businessName: "Test",
            businessId: "id"
        )
        
        let result = RefreshResult(
            business: business,
            success: true,
            hasChanges: true,
            changes: [change],
            error: nil
        )
        
        XCTAssertTrue(result.success)
        XCTAssertTrue(result.hasChanges)
        XCTAssertEqual(result.changes.count, 1)
        XCTAssertNil(result.error)
    }
    
    func testRefreshResultFailure() {
        let business = Business(
            name: "Test",
            address: "Address",
            latitude: 0,
            longitude: 0
        )
        
        let result = RefreshResult(
            business: business,
            success: false,
            hasChanges: false,
            changes: [],
            error: RefreshError.noPlaceId
        )
        
        XCTAssertFalse(result.success)
        XCTAssertFalse(result.hasChanges)
        XCTAssertEqual(result.changes.count, 0)
        XCTAssertNotNil(result.error)
    }
    
    func testRefreshResultNoChanges() {
        let business = Business(
            name: "Test",
            address: "Address",
            latitude: 0,
            longitude: 0
        )
        
        let result = RefreshResult(
            business: business,
            success: true,
            hasChanges: false,
            changes: [],
            error: nil
        )
        
        XCTAssertTrue(result.success)
        XCTAssertFalse(result.hasChanges)
        XCTAssertTrue(result.changes.isEmpty)
    }
    
    // MARK: - RefreshError Tests
    
    func testRefreshErrorTypes() {
        let noPlaceIdError = RefreshError.noPlaceId
        let apiError = RefreshError.apiError
        let noDataError = RefreshError.noData
        
        // Verify errors are distinct
        XCTAssertTrue(noPlaceIdError as Error is RefreshError)
        XCTAssertTrue(apiError as Error is RefreshError)
        XCTAssertTrue(noDataError as Error is RefreshError)
    }
    
    // MARK: - Helper Methods (Using Mirror to access private methods)
    
    private func callFormatTime(_ minutes: Int) -> String {
        // Create a test instance and use reflection to call private method
        let mirror = Mirror(reflecting: refreshService)
        
        // For testing purposes, we'll implement the same logic here
        // This matches the implementation in BusinessRefreshService
        let hour = minutes / 60
        let minute = minutes % 60
        let period = hour < 12 ? "AM" : "PM"
        let displayHour = hour == 0 ? 12 : (hour > 12 ? hour - 12 : hour)
        return String(format: "%d:%02d %@", displayHour, minute, period)
    }
    
    private func callDayName(_ weekday: Int) -> String {
        // For testing purposes, we'll implement the same logic here
        let days = ["", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        guard weekday >= 1 && weekday <= 7 else { return "Unknown" }
        return days[weekday]
    }
}
