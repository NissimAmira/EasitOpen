//
//  BusinessTests.swift
//  EasitOpenTests
//
//  Created by nissim amira on 04/12/2025.
//

import XCTest
import SwiftData
import CoreLocation
@testable import EasitOpen
internal import SwiftUI

final class BusinessTests: XCTestCase {
    
    func testBusinessIsOpenDuringHours() {
        // Create a schedule for today, 9 AM - 5 PM
        let calendar = Calendar.current
        let today = calendar.component(.weekday, from: Date())
        let schedule = DaySchedule(weekday: today, openTime: 540, closeTime: 1020)
        
        let business = Business(
            name: "Test Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: [schedule]
        )
        
        // Test will pass if executed during business hours (9 AM - 5 PM)
        // In production, you'd inject time for deterministic testing
        let hour = calendar.component(.hour, from: Date())
        let isBusinessHours = hour >= 9 && hour < 17
        XCTAssertEqual(business.isOpen, isBusinessHours)
    }
    
    func testDisplayNameUsesCustomLabel() {
        let business = Business(
            name: "Original Name",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        // Without custom label
        XCTAssertEqual(business.displayName, "Original Name")
        
        // With custom label
        business.customLabel = "My Custom Name"
        XCTAssertEqual(business.displayName, "My Custom Name")
    }
    
    func testBusinessInitialization() {
        let business = Business(
            name: "Coffee Shop",
            address: "123 Main St",
            latitude: 32.0853,
            longitude: 34.7818,
            phoneNumber: "123-456-7890",
            website: "https://example.com"
        )
        
        XCTAssertEqual(business.name, "Coffee Shop")
        XCTAssertEqual(business.address, "123 Main St")
        XCTAssertEqual(business.latitude, 32.0853, accuracy: 0.0001)
        XCTAssertEqual(business.longitude, 34.7818, accuracy: 0.0001)
        XCTAssertEqual(business.phoneNumber, "123-456-7890")
        XCTAssertEqual(business.website, "https://example.com")
        XCTAssertNil(business.customLabel)
    }
    
    func testCustomLabelCanBeCleared() {
        let business = Business(
            name: "Test Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        business.customLabel = "Custom"
        XCTAssertEqual(business.displayName, "Custom")
        
        business.customLabel = nil
        XCTAssertEqual(business.displayName, "Test Business")
    }
    
    // MARK: - Status Tests
    
    func testBusinessStatusOpen() {
        // Create a schedule that opened 1 hour ago and closes in 90 minutes
        let calendar = Calendar.current
        let now = Date()
        let today = calendar.component(.weekday, from: now)
        let currentHour = calendar.component(.hour, from: now)
        let currentMinute = calendar.component(.minute, from: now)
        let currentMinutes = currentHour * 60 + currentMinute
        
        let openTime = currentMinutes - 60  // Opened 1 hour ago
        let closeTime = currentMinutes + 90 // Closes in 90 minutes (>60, so OPEN)
        let schedule = DaySchedule(weekday: today, openTime: openTime, closeTime: closeTime)
        
        let business = Business(
            name: "Open Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: [schedule]
        )
        
        XCTAssertEqual(business.status, .open, "Business should be OPEN when more than 60 minutes until closing")
        XCTAssertTrue(business.isOpen, "isOpen should be true for open status")
    }
    
    func testBusinessStatusClosingSoon() {
        // Create a schedule that closes in 45 minutes
        let calendar = Calendar.current
        let now = Date()
        let today = calendar.component(.weekday, from: now)
        let currentHour = calendar.component(.hour, from: now)
        let currentMinute = calendar.component(.minute, from: now)
        let currentMinutes = currentHour * 60 + currentMinute
        
        let openTime = currentMinutes - 60  // Opened 1 hour ago
        let closeTime = currentMinutes + 45 // Closes in 45 minutes
        let schedule = DaySchedule(weekday: today, openTime: openTime, closeTime: closeTime)
        
        let business = Business(
            name: "Closing Soon Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: [schedule]
        )
        
        XCTAssertEqual(business.status, .closingSoon, "Business should be CLOSING SOON when within 60 minutes of closing")
        XCTAssertTrue(business.isOpen, "isOpen should be true for closingSoon status")
    }
    
    func testBusinessStatusClosingSoonEdgeCase() {
        // Test exactly 60 minutes until closing
        let calendar = Calendar.current
        let now = Date()
        let today = calendar.component(.weekday, from: now)
        let currentHour = calendar.component(.hour, from: now)
        let currentMinute = calendar.component(.minute, from: now)
        let currentMinutes = currentHour * 60 + currentMinute
        
        let openTime = currentMinutes - 60
        let closeTime = currentMinutes + 60 // Exactly 60 minutes
        let schedule = DaySchedule(weekday: today, openTime: openTime, closeTime: closeTime)
        
        let business = Business(
            name: "Edge Case Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: [schedule]
        )
        
        XCTAssertEqual(business.status, .closingSoon, "Business should be CLOSING SOON at exactly 60 minutes")
    }
    
    func testBusinessStatusClosed() {
        // Create a schedule for yesterday
        let calendar = Calendar.current
        let today = calendar.component(.weekday, from: Date())
        let yesterday = today == 1 ? 7 : today - 1
        
        let schedule = DaySchedule(weekday: yesterday, openTime: 540, closeTime: 1020)
        
        let business = Business(
            name: "Closed Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: [schedule]
        )
        
        XCTAssertEqual(business.status, .closed, "Business should be CLOSED when it's not the scheduled day")
        XCTAssertFalse(business.isOpen, "isOpen should be false for closed status")
    }
    
    func testBusinessStatusClosedBeforeOpening() {
        // Create a schedule that opens in 2 hours
        let calendar = Calendar.current
        let now = Date()
        let today = calendar.component(.weekday, from: now)
        let currentHour = calendar.component(.hour, from: now)
        let currentMinute = calendar.component(.minute, from: now)
        let currentMinutes = currentHour * 60 + currentMinute
        
        let openTime = currentMinutes + 120 // Opens in 2 hours
        let closeTime = currentMinutes + 300 // Closes in 5 hours
        let schedule = DaySchedule(weekday: today, openTime: openTime, closeTime: closeTime)
        
        let business = Business(
            name: "Not Yet Open Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: [schedule]
        )
        
        XCTAssertEqual(business.status, .closed, "Business should be CLOSED before opening time")
        XCTAssertFalse(business.isOpen)
    }
    
    func testBusinessStatusClosedAfterClosing() {
        // Create a schedule that closed 1 hour ago
        let calendar = Calendar.current
        let now = Date()
        let today = calendar.component(.weekday, from: now)
        let currentHour = calendar.component(.hour, from: now)
        let currentMinute = calendar.component(.minute, from: now)
        let currentMinutes = currentHour * 60 + currentMinute
        
        let openTime = currentMinutes - 300 // Opened 5 hours ago
        let closeTime = currentMinutes - 60 // Closed 1 hour ago
        let schedule = DaySchedule(weekday: today, openTime: openTime, closeTime: closeTime)
        
        let business = Business(
            name: "Already Closed Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: [schedule]
        )
        
        XCTAssertEqual(business.status, .closed, "Business should be CLOSED after closing time")
        XCTAssertFalse(business.isOpen)
    }
    
    func testBusinessStatusWithNoSchedule() {
        let business = Business(
            name: "No Schedule Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0,
            openingHours: []
        )
        
        XCTAssertEqual(business.status, .closed, "Business with no schedule should be CLOSED")
        XCTAssertFalse(business.isOpen)
    }
    
    // MARK: - Status Enum Tests
    
    func testBusinessStatusText() {
        XCTAssertEqual(BusinessStatus.open.text, "OPEN")
        XCTAssertEqual(BusinessStatus.closingSoon.text, "CLOSING SOON")
        XCTAssertEqual(BusinessStatus.closed.text, "CLOSED")
    }
    
    func testBusinessStatusColors() {
        XCTAssertEqual(BusinessStatus.open.color, .green)
        XCTAssertEqual(BusinessStatus.closingSoon.color, .orange)
        XCTAssertEqual(BusinessStatus.closed.color, .red)
    }
    
    // MARK: - Data Tracking Tests
    
    func testBusinessInitializationSetsTimestamps() {
        let beforeCreation = Date()
        
        let business = Business(
            name: "Test Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        let afterCreation = Date()
        
        // lastUpdated should be set to current time on creation
        XCTAssertGreaterThanOrEqual(business.lastUpdated, beforeCreation)
        XCTAssertLessThanOrEqual(business.lastUpdated, afterCreation)
        
        // lastChecked should be nil initially
        XCTAssertNil(business.lastChecked)
    }
    
    func testBusinessStoresGooglePlaceId() {
        let placeId = "ChIJN1t_tDeuEmsRUsoyG83frY4"
        
        let business = Business(
            googlePlaceId: placeId,
            name: "Test Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        XCTAssertEqual(business.googlePlaceId, placeId)
    }
    
    // MARK: - Staleness Tests
    
    func testIsDataStaleFreshData() {
        // Business just created - should not be stale
        let business = Business(
            name: "Fresh Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        XCTAssertFalse(business.isDataStale, "Freshly created business should not be stale")
    }
    
    func testIsDataStaleOldData() {
        let business = Business(
            name: "Old Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        // Manually set lastUpdated to 8 days ago
        let calendar = Calendar.current
        business.lastUpdated = calendar.date(byAdding: .day, value: -8, to: Date())!
        
        XCTAssertTrue(business.isDataStale, "Business with 8-day-old data should be stale")
    }
    
    func testIsDataStaleEdgeCase() {
        let business = Business(
            name: "Edge Case Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        // Set to exactly 7 days ago
        let calendar = Calendar.current
        business.lastUpdated = calendar.date(byAdding: .day, value: -7, to: Date())!
        
        // At exactly 7 days, should not be stale (>7 required)
        XCTAssertFalse(business.isDataStale, "Business at exactly 7 days should not be stale")
    }
    
    func testLastUpdatedTextFormat() {
        let business = Business(
            name: "Test Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        // Set to 2 hours ago
        let calendar = Calendar.current
        business.lastUpdated = calendar.date(byAdding: .hour, value: -2, to: Date())!
        
        let text = business.lastUpdatedText
        
        // Should contain relative time format (e.g., "2 hr ago", "2 hours ago")
        XCTAssertFalse(text.isEmpty, "lastUpdatedText should not be empty")
        XCTAssertTrue(text.contains("ago") || text.contains("hr"), "Should be a relative time format")
    }
    
    func testLastUpdatedTextForRecentUpdate() {
        let business = Business(
            name: "Test Business",
            address: "Test Address",
            latitude: 0,
            longitude: 0
        )
        
        // Just created - lastUpdated is now
        let text = business.lastUpdatedText
        
        // Should show something like "just now" or "0 min ago"
        XCTAssertFalse(text.isEmpty)
    }
    
    // MARK: - Location and Distance Tests
    
    func testBusinessLocationProperty() {
        let latitude = 32.0853
        let longitude = 34.7818
        
        let business = Business(
            name: "Test Business",
            address: "Tel Aviv",
            latitude: latitude,
            longitude: longitude
        )
        
        let location = business.location
        
        XCTAssertEqual(location.coordinate.latitude, latitude, accuracy: 0.0001)
        XCTAssertEqual(location.coordinate.longitude, longitude, accuracy: 0.0001)
    }
    
    func testDistanceCalculation() {
        // Business in Tel Aviv
        let business = Business(
            name: "Tel Aviv Business",
            address: "Tel Aviv",
            latitude: 32.0853,
            longitude: 34.7818
        )
        
        // Reference location in Jerusalem (approximately 60km away)
        let jerusalemLocation = CLLocation(latitude: 31.7683, longitude: 35.2137)
        
        let distance = business.distance(from: jerusalemLocation)
        
        // Distance should be approximately 60,000 meters (60km)
        XCTAssertGreaterThan(distance, 50000, "Distance should be greater than 50km")
        XCTAssertLessThan(distance, 70000, "Distance should be less than 70km")
    }
    
    func testDistanceTextFormatKilometers() {
        let business = Business(
            name: "Test Business",
            address: "Test",
            latitude: 32.0,
            longitude: 34.0
        )
        
        // Location 10km away
        let farLocation = CLLocation(latitude: 32.09, longitude: 34.0)
        let distanceText = business.distanceText(from: farLocation)
        
        // Should display in kilometers
        XCTAssertTrue(distanceText.contains("km"), "Distance >= 1km should show 'km'")
    }
    
    func testDistanceTextFormatMeters() {
        let business = Business(
            name: "Test Business",
            address: "Test",
            latitude: 32.0,
            longitude: 34.0
        )
        
        // Location very close (< 1km)
        let nearLocation = CLLocation(latitude: 32.001, longitude: 34.001)
        let distanceText = business.distanceText(from: nearLocation)
        
        // Should display in meters
        XCTAssertTrue(distanceText.contains("m"), "Distance < 1km should show 'm'")
        XCTAssertFalse(distanceText.contains("km"), "Distance < 1km should not show 'km'")
    }
    
    func testDistanceToSameLocation() {
        let latitude = 32.0853
        let longitude = 34.7818
        
        let business = Business(
            name: "Test Business",
            address: "Test",
            latitude: latitude,
            longitude: longitude
        )
        
        let sameLocation = CLLocation(latitude: latitude, longitude: longitude)
        let distance = business.distance(from: sameLocation)
        
        // Distance should be very close to 0
        XCTAssertLessThan(distance, 1, "Distance to same location should be < 1 meter")
    }
    
    func testDistanceTextForZeroDistance() {
        let latitude = 32.0853
        let longitude = 34.7818
        
        let business = Business(
            name: "Test Business",
            address: "Test",
            latitude: latitude,
            longitude: longitude
        )
        
        let sameLocation = CLLocation(latitude: latitude, longitude: longitude)
        let distanceText = business.distanceText(from: sameLocation)
        
        // Should show "0 m" for same location
        XCTAssertTrue(distanceText.contains("0"))
        XCTAssertTrue(distanceText.contains("m"))
    }
    
    func testDistanceAcrossGlobe() {
        // Business in Tel Aviv
        let business = Business(
            name: "Tel Aviv Business",
            address: "Tel Aviv",
            latitude: 32.0853,
            longitude: 34.7818
        )
        
        // Location in New York (very far away)
        let newYorkLocation = CLLocation(latitude: 40.7128, longitude: -74.0060)
        
        let distance = business.distance(from: newYorkLocation)
        
        // Distance should be thousands of kilometers
        XCTAssertGreaterThan(distance, 8000000, "Distance Tel Aviv to NYC should be > 8000km")
    }
    
    func testDistanceSorting() {
        let referenceLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        
        // Create businesses at different distances
        let nearBusiness = Business(
            name: "Near",
            address: "Near",
            latitude: 32.001,
            longitude: 34.001
        )
        
        let farBusiness = Business(
            name: "Far",
            address: "Far",
            latitude: 32.1,
            longitude: 34.1
        )
        
        let businesses = [farBusiness, nearBusiness]
        let sorted = businesses.sorted { b1, b2 in
            b1.distance(from: referenceLocation) < b2.distance(from: referenceLocation)
        }
        
        // Near business should come first after sorting
        XCTAssertEqual(sorted[0].name, "Near")
        XCTAssertEqual(sorted[1].name, "Far")
    }
}
