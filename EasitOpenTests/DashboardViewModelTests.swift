//
//  DashboardViewModelTests.swift
//  EasitOpenTests
//
//  Created by nissim amira on 05/12/2025.
//

import XCTest
import CoreLocation
@testable import EasitOpen

@MainActor
final class DashboardViewModelTests: XCTestCase {
    var viewModel: DashboardViewModel!
    var mockRefreshService: MockBusinessRefreshService!
    var mockLocationManager: MockLocationManager!
    
    override func setUp() async throws {
        try await super.setUp()
        mockRefreshService = MockBusinessRefreshService()
        mockLocationManager = MockLocationManager()
        viewModel = DashboardViewModel(
            refreshService: mockRefreshService,
            locationManager: mockLocationManager
        )
    }
    
    override func tearDown() async throws {
        viewModel = nil
        mockRefreshService = nil
        mockLocationManager = nil
        try await super.tearDown()
    }
    
    // MARK: - Filtering Tests
    
    func testFilteredAndSorted_NoFilter() {
        let businesses = createSampleBusinesses()
        let result = viewModel.filteredAndSorted(businesses)
        XCTAssertEqual(result.count, 3)
    }
    
    func testFilteredAndSorted_OpenNowFilter() {
        let businesses = createSampleBusinesses()
        viewModel.filterOption = .openNow
        let result = viewModel.filteredAndSorted(businesses)
        // Should filter to only currently open businesses
        XCTAssertTrue(result.allSatisfy { $0.status == .open })
    }
    
    func testFilteredAndSorted_ClosedFilter() {
        let businesses = createSampleBusinesses()
        viewModel.filterOption = .closed
        let result = viewModel.filteredAndSorted(businesses)
        // Should filter to only closed businesses
        XCTAssertTrue(result.allSatisfy { $0.status == .closed })
    }
    
    func testFilteredAndSorted_StaleDataFilter() {
        let businesses = createSampleBusinesses()
        viewModel.filterOption = .staleData
        let result = viewModel.filteredAndSorted(businesses)
        // Should filter to only stale data
        XCTAssertTrue(result.allSatisfy { $0.isDataStale })
    }
    
    // MARK: - Sorting Tests
    
    func testFilteredAndSorted_NameSort() {
        let businesses = createSampleBusinesses()
        viewModel.sortOption = .name
        let result = viewModel.filteredAndSorted(businesses)
        // Should be sorted alphabetically
        for i in 0..<(result.count - 1) {
            XCTAssertLessThanOrEqual(result[i].displayName, result[i + 1].displayName)
        }
    }
    
    func testFilteredAndSorted_DistanceFromCurrentSort_WithLocation() {
        let businesses = createSampleBusinesses()
        mockLocationManager.mockCurrentLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        viewModel.sortOption = .distanceFromCurrent
        let result = viewModel.filteredAndSorted(businesses)
        // Should be sorted by distance when location available
        for i in 0..<(result.count - 1) {
            let distance1 = result[i].distance(to: mockLocationManager.mockCurrentLocation!)
            let distance2 = result[i + 1].distance(to: mockLocationManager.mockCurrentLocation!)
            XCTAssertLessThanOrEqual(distance1, distance2)
        }
    }
    
    func testFilteredAndSorted_DistanceFromCurrentSort_WithoutLocation() {
        let businesses = createSampleBusinesses()
        mockLocationManager.mockCurrentLocation = nil
        viewModel.sortOption = .distanceFromCurrent
        let result = viewModel.filteredAndSorted(businesses)
        // Should fallback to name sort when no location
        for i in 0..<(result.count - 1) {
            XCTAssertLessThanOrEqual(result[i].displayName, result[i + 1].displayName)
        }
    }
    
    func testFilteredAndSorted_DistanceFromHomeSort_WithLocation() {
        let businesses = createSampleBusinesses()
        mockLocationManager.mockHomeLocation = CLLocation(latitude: 32.1, longitude: 34.1)
        viewModel.sortOption = .distanceFromHome
        let result = viewModel.filteredAndSorted(businesses)
        // Should be sorted by distance to home
        for i in 0..<(result.count - 1) {
            let distance1 = result[i].distance(to: mockLocationManager.mockHomeLocation!)
            let distance2 = result[i + 1].distance(to: mockLocationManager.mockHomeLocation!)
            XCTAssertLessThanOrEqual(distance1, distance2)
        }
    }
    
    func testFilteredAndSorted_DistanceFromHomeSort_WithoutLocation() {
        let businesses = createSampleBusinesses()
        mockLocationManager.mockHomeLocation = nil
        viewModel.sortOption = .distanceFromHome
        let result = viewModel.filteredAndSorted(businesses)
        // Should fallback to name sort when no home location
        for i in 0..<(result.count - 1) {
            XCTAssertLessThanOrEqual(result[i].displayName, result[i + 1].displayName)
        }
    }
    
    func testFilteredAndSorted_RecentlyUpdatedSort() {
        let businesses = createSampleBusinesses()
        viewModel.sortOption = .recentlyUpdated
        let result = viewModel.filteredAndSorted(businesses)
        // Should be sorted by most recent update
        for i in 0..<(result.count - 1) {
            XCTAssertGreaterThanOrEqual(result[i].lastUpdated, result[i + 1].lastUpdated)
        }
    }
    
    // MARK: - Search Tests
    
    func testFilteredAndSorted_WithSearchText() {
        let businesses = createSampleBusinesses()
        viewModel.searchText = "cafe"
        let result = viewModel.filteredAndSorted(businesses)
        // Should only include businesses matching search
        XCTAssertTrue(result.allSatisfy { business in
            business.displayName.localizedCaseInsensitiveContains("cafe") ||
            business.address.localizedCaseInsensitiveContains("cafe")
        })
    }
    
    func testFilteredAndSorted_WithEmptySearchText() {
        let businesses = createSampleBusinesses()
        viewModel.searchText = ""
        let result = viewModel.filteredAndSorted(businesses)
        XCTAssertEqual(result.count, businesses.count)
    }
    
    // MARK: - Reference Location Tests
    
    func testReferenceLocation_DistanceFromCurrent() {
        mockLocationManager.mockCurrentLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        viewModel.sortOption = .distanceFromCurrent
        let location = viewModel.referenceLocation()
        XCTAssertEqual(location?.coordinate.latitude, 32.0)
        XCTAssertEqual(location?.coordinate.longitude, 34.0)
    }
    
    func testReferenceLocation_DistanceFromHome() {
        mockLocationManager.mockHomeLocation = CLLocation(latitude: 32.1, longitude: 34.1)
        viewModel.sortOption = .distanceFromHome
        let location = viewModel.referenceLocation()
        XCTAssertEqual(location?.coordinate.latitude, 32.1)
        XCTAssertEqual(location?.coordinate.longitude, 34.1)
    }
    
    func testReferenceLocation_OtherSort() {
        mockLocationManager.mockCurrentLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        viewModel.sortOption = .name
        let location = viewModel.referenceLocation()
        XCTAssertNil(location)
    }
    
    // MARK: - Validation Tests
    
    func testValidateSortOption_DistanceFromCurrentWithoutLocation() {
        mockLocationManager.mockCurrentLocation = nil
        viewModel.sortOption = .distanceFromCurrent
        viewModel.validateSortOption()
        // Should fallback to .name when current location unavailable
        XCTAssertEqual(viewModel.sortOption, .name)
    }
    
    func testValidateSortOption_DistanceFromHomeWithoutLocation() {
        mockLocationManager.mockHomeLocation = nil
        viewModel.sortOption = .distanceFromHome
        viewModel.validateSortOption()
        // Should fallback to .name when home location unavailable
        XCTAssertEqual(viewModel.sortOption, .name)
    }
    
    func testValidateSortOption_WithValidLocation() {
        mockLocationManager.mockCurrentLocation = CLLocation(latitude: 32.0, longitude: 34.0)
        viewModel.sortOption = .distanceFromCurrent
        viewModel.validateSortOption()
        // Should remain unchanged when location available
        XCTAssertEqual(viewModel.sortOption, .distanceFromCurrent)
    }
    
    // MARK: - Refresh Tests
    
    func testRefreshAllBusinesses_Success() async throws {
        let businesses = createSampleBusinesses()
        mockRefreshService.mockChanges = [
            BusinessChange(type: .hoursChanged(day: "Monday", oldHours: "9-5", newHours: "10-6"), businessName: "Test", businessId: "1")
        ]
        
        XCTAssertFalse(viewModel.isRefreshing)
        
        await viewModel.refreshAllBusinesses(businesses)
        
        XCTAssertFalse(viewModel.isRefreshing)
        XCTAssertNotNil(viewModel.refreshMessage)
        XCTAssertEqual(viewModel.refreshMessageType, .success)
        XCTAssertTrue(viewModel.refreshMessage!.contains("1 change"))
    }
    
    func testRefreshAllBusinesses_NoChanges() async throws {
        let businesses = createSampleBusinesses()
        mockRefreshService.mockChanges = []
        
        await viewModel.refreshAllBusinesses(businesses)
        
        XCTAssertFalse(viewModel.isRefreshing)
        XCTAssertNotNil(viewModel.refreshMessage)
        XCTAssertEqual(viewModel.refreshMessageType, .info)
        XCTAssertTrue(viewModel.refreshMessage!.contains("up to date"))
    }
    
    func testRefreshAllBusinesses_WithError() async throws {
        let businesses = createSampleBusinesses()
        mockRefreshService.shouldThrowError = true
        
        await viewModel.refreshAllBusinesses(businesses)
        
        XCTAssertFalse(viewModel.isRefreshing)
        XCTAssertNotNil(viewModel.refreshMessage)
        XCTAssertEqual(viewModel.refreshMessageType, .error)
    }
    
    func testRefreshAllBusinesses_MultipleChanges() async throws {
        let businesses = createSampleBusinesses()
        mockRefreshService.mockChanges = [
            BusinessChange(type: .hoursChanged(day: "Monday", oldHours: "9-5", newHours: "10-6"), businessName: "Test1", businessId: "1"),
            BusinessChange(type: .phoneChanged(old: "123", new: "456"), businessName: "Test2", businessId: "2"),
            BusinessChange(type: .websiteChanged(old: "a.com", new: "b.com"), businessName: "Test3", businessId: "3")
        ]
        
        await viewModel.refreshAllBusinesses(businesses)
        
        XCTAssertTrue(viewModel.refreshMessage!.contains("3 changes"))
    }
    
    // MARK: - Helper Methods
    
    private func createSampleBusinesses() -> [Business] {
        let now = Date()
        let staleDate = Calendar.current.date(byAdding: .day, value: -8, to: now)!
        
        let business1 = Business(
            name: "Cafe Alpha",
            address: "123 Main St",
            latitude: 32.0,
            longitude: 34.0,
            phoneNumber: "111",
            website: "alpha.com",
            openingHours: [createOpenSchedule()]
        )
        business1.lastUpdated = now
        
        let business2 = Business(
            name: "Beta Restaurant",
            address: "456 Side St",
            latitude: 32.1,
            longitude: 34.1,
            phoneNumber: "222",
            website: "beta.com",
            openingHours: [createClosedSchedule()]
        )
        business2.lastUpdated = staleDate
        
        let business3 = Business(
            name: "Gamma Shop",
            address: "789 Back St",
            latitude: 32.2,
            longitude: 34.2,
            phoneNumber: "333",
            website: "gamma.com",
            openingHours: [createOpenSchedule()]
        )
        business3.lastUpdated = Calendar.current.date(byAdding: .hour, value: -1, to: now)!
        
        return [business1, business2, business3]
    }
    
    private func createOpenSchedule() -> DaySchedule {
        DaySchedule(weekday: Calendar.current.component(.weekday, from: Date()), openTime: 0, closeTime: 1439, isClosed: false)
    }
    
    private func createClosedSchedule() -> DaySchedule {
        DaySchedule(weekday: Calendar.current.component(.weekday, from: Date()), openTime: 0, closeTime: 0, isClosed: true)
    }
}

// MARK: - Mock Classes

class MockBusinessRefreshService: BusinessRefreshService {
    var mockChanges: [BusinessChange] = []
    var shouldThrowError = false
    
    override func refreshBusiness(_ business: Business) async throws -> [BusinessChange] {
        if shouldThrowError {
            throw RefreshError.apiError
        }
        return mockChanges
    }
}

class MockLocationManager: LocationManager {
    var mockCurrentLocation: CLLocation?
    var mockHomeLocation: CLLocation?
    
    
    override var currentLocation: CLLocation? {
        get { mockCurrentLocation }
        set { mockCurrentLocation = newValue }
    }
    
    override var homeLocation: CLLocation? {
        get { mockHomeLocation }
        set { mockHomeLocation = newValue }
    }
}
